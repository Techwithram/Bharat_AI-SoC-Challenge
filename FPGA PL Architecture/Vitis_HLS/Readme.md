# ‚ö° Vitis HLS Source & Synthesis Workflow

![Tool](https://img.shields.io/badge/Tool-Vitis_HLS_2022.2-purple)
![Language](https://img.shields.io/badge/Language-C%2B%2B_|_Pragmas-blue)
![Output](https://img.shields.io/badge/Output-RTL_IP_Core-success)

This directory contains the C++ source code, header files, and the trained model weights required to synthesize the custom Hardware IPs (Temporal Gate and the MobileNetV2 Accelerator) using AMD/Xilinx Vitis High-Level Synthesis (HLS). 

Instead of writing complex Verilog or VHDL by hand, Vitis HLS allows us to define the neural network and gating logic in C++, applying specific hardware compiler directives (`#pragma`) to automatically generate highly optimized, correct-by-construction Register Transfer Level (RTL) code.

---
<br/>

## üìÇ 1. File Architecture & Descriptions

### `temporal.cpp` & `temporal.h` (The Smart Preprocessor)
* **What they are:** The C++ source and header files for the custom Temporal Gate IP.
* **Why they are created:** To implement the localized frame-differencing logic that acts as a hardware-level power switch, dropping idle video frames before they reach the heavy neural network.
* **How they work:**  The inputs and outputs are defined using the `hls::stream` datatype to natively support the AXI4-Stream video protocol. 
  * An internal static array acts as a line buffer to store the previous frame's pixels. 
  * We utilize `#pragma HLS INTERFACE s_axilite` to expose the gate's sensitivity threshold variable to the ARM processor as a memory-mapped control register.

<br/>

### `accelerator.cpp` & `accelerator.h` (The Layers IP)
* **What they are:** The C++ core of our MobileNetV2 feature-extraction engine.
* **Why they are created:** Standard processors execute matrix multiplications sequentially. This IP explicitly defines the depthwise separable convolutions of Layers 1 through 8 so they can be offloaded to the FPGA's DSP slices.
* **How they work:**  The code consists of deeply nested `for` loops performing the convolution mathematics. 
  * To achieve extreme throughput, we apply `#pragma HLS UNROLL` to physically duplicate the math operations in hardware, and `#pragma HLS PIPELINE` to allow the engine to accept a new pixel every single clock cycle.

<br/>


### `weights.h` (The Bridge from Python to Hardware)
* **What it is:** A massive, autogenerated C++ header file containing flat, 1D constant arrays (`const float` or `const ap_fixed`) of the trained MobileNetV2 weights, biases, and batch normalization parameters.
* **Why it is created:** The Programmable Logic (PL) cannot natively read an `.h5` or `.tflite` file from a hard drive. To process data with zero latency, the trained weights for the first 8 layers must be permanently "baked" into the physical hardware.
* **How it is created:** A custom Python script is used to open the trained Keras model, extract the exact numerical weights for the targeted layers, format them into strict C++ array syntax, and output this `weights.h` file. During synthesis, the Vitis HLS compiler maps these arrays directly into the FPGA's ultra-fast internal Block RAM (BRAM) or Read-Only Memory (ROM).


<br/>

---

<br/>

## ‚öôÔ∏è 2. The Vitis HLS Compilation Workflow

To convert these C++ files into deployable hardware IPs, the following workflow is executed within the Vitis HLS 2022.2 environment:

1. **C Simulation (`C SIM`):**  Before generating any hardware, the C++ code is compiled and run against a standard C testbench using GCC/G++. This fast software simulation guarantees our convolution math and `weights.h` arrays produce the exact same feature maps as the original Python model.
3. **C Synthesis:**   The core engine of HLS. The compiler parses the C++ code and the applied `#pragma` directives to synthesize the logic into Verilog/VHDL. It generates a detailed report outlining the estimated clock latency, BRAM usage, and DSP slice consumption.
4. **C/RTL Co-Simulation:**   The tool automatically injects the original C testbench vectors into the newly generated RTL code and runs a hardware simulator (like XSim) to verify that the physical Verilog behaves identically to the C++ code on a clock-cycle level.
5. **IP Export:**  Once validated, the RTL is packaged into a standard Xilinx IP Core (`.zip` format). This package is then imported into the Vivado Block Design to be wired to the AXI DMA and the Zynq UltraScale+ Processing System.

---
